<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> StAX---基于流的拉式XML解析 · 非典型性程序猿</title><meta name="description" content="StAX---基于流的拉式XML解析 - Justin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.justin-x.cn/atom.xml" title="非典型性程序猿"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/justin890215" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/xiongqi215" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">StAX---基于流的拉式XML解析</h1><div class="post-info">Aug 21, 2014</div><div class="post-content"><p>最近在学习webservice时，发现很多技术框架都在使用StAX作为底层XML解析工具，于是今天看了看资料，简单学习了下，在这里做个总结。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>StAX，全称Streaming API for XML，一种全新的，基于流的JAVA XML解析标准类库。其最终版本于 2004 年 3 月发布，并成为了 JAXP 1.4（将包含在即将发布的 Java 6 中）的一部分。在某种程度上来说，StAX与SAX一样是基于XML事件的解析方式，它们都不会一次性加载整个XML文件。但是它们之间也有很大的不同。</p>
<a id="more"></a>
<h2 id="与SAX相比"><a href="#与SAX相比" class="headerlink" title="与SAX相比"></a>与SAX相比</h2><p>虽然StAX与SAX一样基于XML事件解析，相比于DOM将整个XML加载进内存来说效率高。不同的是，StAX在在处理XML事件的方式上使得应用程序更接近底层，所以在效率上比SAX更优秀。</p>
<p>使用SAX时，我们知道XML事件是由解析器调用开发人员编写的回调方法来处理的，也就是说应用程序是被动于解析器的。应用程序只能被动的等待解析器将XML事件推送给自己处理，对于每一种事件都需要在解析开始之前就做好准备。这种方式被称为‘推（push)‘。<br>而StAX正好相反，StAX采用一种‘拉（pull）‘的方式，由应用程序主动从解析器中获取当前XML事件然后更具需求处理（保存或者忽略）。StAX使得应用程序掌握了主动权，可以简化调用代码来准确地处理它预期的内容，或者发生意外时停止解析。此外，由于该方法不基于处理程序回调，应用程序不需要像使用 SAX 那样模拟解析器的状态。</p>
<h1 id="简单入门"><a href="#简单入门" class="headerlink" title="简单入门"></a>简单入门</h1><p>获取解析器工厂<br>与其他解析技术一样，在使用StAX解析器之前也需要获取其工厂类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.InputStream;  </div><div class="line"><span class="keyword">import</span> java.io.OutputStream;  </div><div class="line"><span class="keyword">import</span> javax.xml.stream.XMLInputFactory;  </div><div class="line"><span class="keyword">import</span> javax.xml.stream.XMLOutputFactory;  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StAX_Frist</span> </span>&#123;  </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeXMlByStream</span><span class="params">(OutputStream out)</span></span>&#123;  </div><div class="line">     XMLOutputFactory outFactor=XMLOutputFactory.newInstance();<span class="comment">//写解析器工厂  </span></div><div class="line">     .......  </div><div class="line"> &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">readXmlByStream</span><span class="params">(InputStream in)</span></span>&#123;  </div><div class="line">          </div><div class="line">        XMLInputFactory inFactory=XMLInputFactory.newInstance();<span class="comment">//读解析器工厂  </span></div><div class="line">        .......  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="主要API"><a href="#主要API" class="headerlink" title="主要API"></a>主要API</h2><p>StAX 实际上包括两套处理 XML 的 API，分别提供了不同程度的抽象。基于指针（Cursor）的 API 允许应用程序把 XML 作为一个标记（或事件）流来处理。在这里，解析器就像一跟指针一样在文件流上前进，应用程序可以跟随解析器从文件的开头一直处理到结尾。这是一种低层 API，尽管效率高，但是没有提供底层 XML 结构的抽象。Cursor API 由两个主要API组成，XMLStreamReader和XMLStreamWriter，分别由XMLInputStreamFactory和XMLOutputStreamFactory获取。<br>使用Cursor API 读XML文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.InputStream;  </div><div class="line"><span class="keyword">import</span> javax.xml.stream.XMLInputFactory;;  </div><div class="line"><span class="keyword">import</span> javax.xml.stream.XMLStreamConstants;  </div><div class="line"><span class="keyword">import</span> javax.xml.stream.XMLStreamReader;  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StAX_Frist</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">readXmlByStream</span><span class="params">(InputStream in)</span></span>&#123;  </div><div class="line">          </div><div class="line">        XMLInputFactory inFactory=XMLInputFactory.newInstance();<span class="comment">//读解析器工厂  </span></div><div class="line">          </div><div class="line">  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            XMLStreamReader reader=inFactory.createXMLStreamReader(in);<span class="comment">//获取读解析器  </span></div><div class="line">            <span class="keyword">while</span>(reader.hasNext())&#123;<span class="comment">//reader.hasNext();说明文件未到结尾。  </span></div><div class="line">                <span class="keyword">int</span> eventId=reader.next();  </div><div class="line">                <span class="keyword">switch</span> (eventId) &#123;  </div><div class="line">                <span class="keyword">case</span> XMLStreamConstants.START_DOCUMENT:  </div><div class="line">                    System.out.println(<span class="string">"start docmuent"</span>);  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                      </div><div class="line">                <span class="keyword">case</span> XMLStreamConstants.START_ELEMENT:  </div><div class="line">                    System.out.println(<span class="string">"&lt;"</span>+reader.getLocalName()+<span class="string">"&gt;"</span>);  </div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;reader.getAttributeCount();i++)&#123;  </div><div class="line">                        System.out.println(reader.getAttributeLocalName(i)+<span class="string">"="</span>+reader.getAttributeValue(i));  </div><div class="line">                    &#125;  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                      </div><div class="line">                <span class="keyword">case</span> XMLStreamConstants.CHARACTERS:  </div><div class="line">                    <span class="keyword">if</span>(reader.isWhiteSpace())&#123;  </div><div class="line">                        <span class="keyword">break</span>;  </div><div class="line">                    &#125;  </div><div class="line">                    System.out.println(reader.getText());  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                <span class="keyword">case</span> XMLStreamConstants.END_ELEMENT:  </div><div class="line">                    System.out.println(<span class="string">"&lt;/"</span>+reader.getLocalName()+<span class="string">"&gt;"</span>);  </div><div class="line">                      </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                <span class="keyword">case</span> XMLStreamConstants.END_DOCUMENT:  </div><div class="line">                    System.out.println(<span class="string">"end docmuent"</span>);  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                <span class="keyword">default</span>:  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>另外一种是较为高级的基于迭代器（Iterator）的 API ，它允许应用程序把 XML 作为一系列事件对象来处理，每个对象和应用程序交换 XML 结构的一部分。应用程序只需要确定解析事件的类型，将其转换成对应的具体类型，然后利用其方法获得属于该事件的信息。基于事件迭代器的方法具有一个基于指针的方法不具备的重要优点。通过将解析器事件变成一级对象，从而让应用程序可以采用面向对象的方式处理它们。这样做有助于模块化和不同应用程序组件之间的代码重用。Iterator API 由两个主要API组成，XMLEventReader和XMLEventWriter，分别由XMLInputStreamFactory和XMLOutputStreamFactory获取。<br>使用Iterator API 读XML文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.InputStream;  </div><div class="line"><span class="keyword">import</span> java.util.Iterator;  </div><div class="line"><span class="keyword">import</span> javax.xml.stream.XMLEventReader;  </div><div class="line"><span class="keyword">import</span> javax.xml.stream.XMLInputFactory;  </div><div class="line"><span class="keyword">import</span> javax.xml.stream.XMLStreamConstants;  </div><div class="line"><span class="keyword">import</span> javax.xml.stream.events.Attribute;  </div><div class="line"><span class="keyword">import</span> javax.xml.stream.events.Characters;  </div><div class="line"><span class="keyword">import</span> javax.xml.stream.events.StartElement;  </div><div class="line"><span class="keyword">import</span> javax.xml.stream.events.XMLEvent;  </div><div class="line">  </div><div class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StAX_Frist</span> </span>&#123;  </div><div class="line">      </div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">readXmlByEvent</span><span class="params">(InputStream in)</span></span>&#123;  </div><div class="line">          </div><div class="line">        XMLInputFactory factory=XMLInputFactory.newInstance();<span class="comment">//获取解析器工厂  </span></div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            XMLEventReader reader=factory.createXMLEventReader(in);<span class="comment">//获取解析器  </span></div><div class="line">            <span class="keyword">while</span>(reader.hasNext())&#123;  </div><div class="line">            XMLEvent event=reader.nextEvent();  </div><div class="line">              </div><div class="line">                <span class="keyword">switch</span> (event.getEventType()) &#123;  </div><div class="line">                <span class="keyword">case</span> XMLStreamConstants.START_DOCUMENT:  </div><div class="line">                    System.out.println(<span class="string">"start docmuent"</span>);  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                      </div><div class="line">                <span class="keyword">case</span> XMLStreamConstants.START_ELEMENT:  </div><div class="line">                    StartElement element=(StartElement)event;  </div><div class="line">                    System.out.println(<span class="string">"&lt;"</span>+element.getName().getLocalPart()+<span class="string">"&gt;"</span>);  </div><div class="line">                    <span class="keyword">for</span>(Iterator it=element.getAttributes();it.hasNext();)&#123;  </div><div class="line">                        Attribute attr=(Attribute) it.next();  </div><div class="line">                        System.out.println(attr.getName().getLocalPart()+<span class="string">"="</span>+attr.getValue());  </div><div class="line">                    &#125;  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                      </div><div class="line">                <span class="keyword">case</span> XMLStreamConstants.CHARACTERS:  </div><div class="line">                    Characters charData=(Characters)event;  </div><div class="line">                    <span class="keyword">if</span>(charData.isIgnorableWhiteSpace()&amp;&amp;charData.isWhiteSpace())&#123;  </div><div class="line">                        <span class="keyword">break</span>;  </div><div class="line">                    &#125;  </div><div class="line">                    System.out.println(charData.getData());  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                <span class="keyword">case</span> XMLStreamConstants.END_ELEMENT:  </div><div class="line">                    element=(StartElement)event;  </div><div class="line">                    System.out.println(<span class="string">"&lt;/"</span>+element.getName().getLocalPart()+<span class="string">"&gt;"</span>);  </div><div class="line">                      </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                <span class="keyword">case</span> XMLStreamConstants.END_DOCUMENT:  </div><div class="line">                    System.out.println(<span class="string">"end docmuent"</span>);  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                <span class="keyword">default</span>:  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></div></article></div></section><footer><div class="paginator"><a href="/2014/08/21/javaXml-Api-intro/" class="prev">上一篇</a></div><div data-thread-key="2014/08/21/stAX-Api-intro/" data-title="StAX---基于流的拉式XML解析" data-url="http://www.justin-x.cn/2014/08/21/stAX-Api-intro/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"Justin-Blog"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260236137'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1260236137%26show%3Dpic' type='text/javascript'%3E%3C/script%3E")); </script>© 2015 - 2016 <a href="http://www.justin-x.cn">Justin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a></p></div><script>(function(){
var bp = document.createElement('script');
var curProtocol = window.location.protocol.split(':')[0];
if (curProtocol === 'https') {
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
}
else {
   bp.src = 'http://push.zhanzhang.baidu.com/push.js';
}
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(bp, s);
})();</script></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>