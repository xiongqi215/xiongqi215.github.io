<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浅析SAX,DOM,JAXP,JDOM与DOM4J之间的关系 · 非典型性程序猿</title><meta name="description" content="浅析SAX,DOM,JAXP,JDOM与DOM4J之间的关系 - Justin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.justin-x.cn/atom.xml" title="非典型性程序猿"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/justin890215" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/xiongqi215" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">浅析SAX,DOM,JAXP,JDOM与DOM4J之间的关系</h1><div class="post-info">Aug 21, 2014</div><div class="post-content"><p><img src="http://7xrvdu.com1.z0.glb.clouddn.com/javaXmlApi.jpg" alt="java xml api"><br><em>图片来源百度</em></p>
<p>众所周知，<code>SAX</code>与<code>DOM</code>是JAVA中两大核心XML解析API类库，而<code>JAXP</code>,<code>JDOM</code>与<code>DOM4J</code>都是基于这两大核心API而衍生出来的。今日兴起看了看相关资料，写篇文章总结总结^.^。<br><a id="more"></a></p>
<h1 id="SAX与DOM"><a href="#SAX与DOM" class="headerlink" title="SAX与DOM"></a>SAX与DOM</h1><p>首先需要说明白的是SAX与DOM的关系。</p>
<p><code>SAX</code>与<code>DOM</code>都是底层API，在JDK中他们的包路径分别为：org.xml.sax与org.w3c.dom。自JDK1.5开始，JDK中自带的实现为Apache的<code>xerces</code>（位于com.sun.org.apache.xerces.internal.parsers下）。</p>
<p><code>SAX</code>是<code>Simple API for XML</code>的简称，它是在JAVA平台上第一个被广泛使用的XML API。也就说它是为JAVA而出现的。目前已经有多个语言版本，比如C++。<br><code>DOM</code>是<code>Documents Object Model</code>的简称，与SAX不同的是，DOM是<code>W3C</code>的标准，它出现的目的是为了实现一套跨平台与语言的标准。</p>
<p>以上是它们之间的第一个不同。第二个，就是解析方式的不同。</p>
<p>SAX是<code>基于事件解析</code>，解析过程中根据目前的XML元素类型，调用用户自己实现的回调方法（或着叫事件方法）来处理，如：<code>startDocument();</code>，<code>startElement();</code> 。<br>SAX2.0中有4个核心接口：</p>
<ul>
<li>org.xml.sax.ContentHander</li>
<li>org.xml.sax.ErrorHandler</li>
<li>org.xml.sax.DTDHandler</li>
<li>org.xml.sax.EntityResolver</li>
</ul>
<p>实现这几个Handler，然后调用解析器相应的set方法注册给解析器，就可以完成各种元素的解析与处理。 对应的注册进解析器的方法分别是：</p>
<ul>
<li>parser.setContentHandler(ContentHander handler)</li>
<li>parser.setErrorHandler(ErrorHandler handler)</li>
<li>parser.setDTDHandler(DTDHandler handler)<br>完整例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> DefaultHandler  handler=<span class="keyword">new</span> XmlParserHandler();<span class="comment">//DefaultHandler已经实现了全部org.xml.sax.ContentHandler，  </span></div><div class="line">                                                   <span class="comment">//org.xml.sax.ErrortHandler，org.xml.sax.DTDHandler和org.xml.sax.EntityHandler接口  </span></div><div class="line"> XMLReader xr=XMLReaderFactory.createXMLReader();<span class="comment">//获取解析器实例  </span></div><div class="line"> xr.setContentHandler(handler);<span class="comment">//设置处理类  </span></div><div class="line">        xr.setErrorHandler(handler);  </div><div class="line">        xr.setDTDHandler(handler);  </div><div class="line">xr.setFeature(<span class="string">"http://xml.org/sax/features/validation"</span>, <span class="keyword">true</span>);<span class="comment">//开启DTD验证  </span></div><div class="line">xr.setFeature(<span class="string">"http://apache.org/xml/features/validation/schema"</span>, <span class="keyword">true</span>);<span class="comment">//开启SCHMAE验证  </span></div><div class="line">xr.parse(<span class="keyword">new</span> InputSource(<span class="string">"F:/Work/Workspace/XmlStudy/test.xml"</span>));</div></pre></td></tr></table></figure>
</li>
</ul>
<p>基于事件处理的好处是，不需要等到整个XML文件被加载完成后在开始处理，而是加载到哪处理到哪。这样便带来了效率上的优势。但是其也有明显的不足，第一个不足便是无法随机访问元素。如果你只想获取第二元素的信息，那么你必须等到第一个元素处理完成后，第二个元素开始的时候。如果这时，你又需要返回第一个元素，那么对不起，已经来不及了。SAX不会主动记忆或保存已处理过的元素（为了效率）。为了实现前面的需求，开发人员需要自己使用容器来保存处理过的元素，并且建立一个模型来表示XML的树形结构。这样一来也就带来了第二个缺点，使用的复杂性。</p>
<p>再来说说DOM。DOM采用了解析方式是<code>一次性加载</code>整个XML文档，在内存中形成一个树形的数据结构，这个数据结构我们称为文档对象模型。通过DOM解析器获取Documen文档t对象后，开发人员可以很方便的对其进行操作，如<code>getDocumentElement();（获取更元素）</code>，<code>getFirstChild();获取一个子元素</code>，<code>appendChild();增加子元素</code>，<code>removeChild();移除子元素</code>。因此，使用DOM可以很方便对XML中的数据进行获取与修改，而不需要像SAX一样自己设计模型保存获取的数据。<br>完整例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DOMParser dp=<span class="keyword">new</span> DOMParser();  </div><div class="line">dp.parse(<span class="keyword">new</span> InputSource(<span class="string">"e:/test.xml"</span>));  </div><div class="line">Document doc=dp.getDocument();  </div><div class="line">Element rootElemet=doc.getDocumentElement();  </div><div class="line">NodeList list=rootElemet.getChildNodes();</div></pre></td></tr></table></figure></p>
<p><strong>跟重要的一点是</strong>，在DOM中所有Element都是Node，这意味着，我们不需要明确知道文档的结构就可以操作它。我们可以判断当前获取到的任意Node对象类型来做不同操作。主要Node类型有：</p>
<pre><code>- Node.DOCUMENT_NODE
- Node.ELEMENT_NODE
- Node.TEXT_NODE
- Node.CDATA_SECTION_NODE
- Node.PROCESSING_INSTRUCTION_NODE
- Node.ENTITY_REFERENCE_NODE
- Node.DOCUMENT_TYPE_NODE
</code></pre><p>但是，由于DOM是一次性加载整个XML文件到内存， 如果XML文件非常庞大，构建文档树的内存与时间开销会很大，且很有可能导致内存溢出异常。</p>
<p>那么如何在SAX与DOM直接选择呢？这取决于下面几个因素：</p>
<ol>
<li>应用程序的目的：如果打算对数据作出更改并将它输出为 XML，那么在大多数情况下，DOM 是适当的选择。并不是说使用 SAX 就不能更改数据，但是该过程要复杂得多，因为您必须对数据的一份拷贝而不是对数据本身作出更改。</li>
<li>数据容量： 对于大型文件，SAX 是更好的选择。</li>
<li>数据将如何使用：如果只有数据中的少量部分会被使用，那么使用 SAX 来将该部分数据提取到应用程序中可能更好。 另一方面，如果您知道自己以后会回头引用已处理过的大量信息，那么 SAX 也许不是恰当的选择。</li>
<li>对速度的需要： SAX 实现通常要比 DOM 实现更快。</li>
</ol>
<blockquote>
<p><code>SAX</code> 和 <code>DOM</code> 不是相互排斥的，记住这点很重要。您可以使用 DOM 来创建 SAX 事件流，也可以使用 SAX 来创建 DOM 树。事实上，用于创建 DOM 树的大多数解析器实际上都使用 SAX 来完成这个任务，比如<code>DOM4J</code>与<code>JDOM</code>！</p>
</blockquote>
<h1 id="JAXP-JDOM与DOM4J"><a href="#JAXP-JDOM与DOM4J" class="headerlink" title="JAXP,JDOM与DOM4J"></a>JAXP,JDOM与DOM4J</h1><h2 id="JAXP"><a href="#JAXP" class="headerlink" title="JAXP"></a>JAXP</h2><p><code>JAXP</code>，全称<code>Java API for XML Processing</code>，打开其为JDK的目录：javax.xml.parsers， 你会发现它与SAX和DOM一样只是一套API。实际上，JAXP出现时SUN公司为了弥补JAVA在XML标准制定上的空白而制定的一套JAVA XML标准API。它并没有为JAVA解析XML提供任何新功能，但是它为在JAVA获取SAX与DOM解析器提供了更加直接的途径。它封装了SAX与DOM两种接口，并在SAX与DOM的基础之上，作了一套比较简单的api以供开发。<br>例如：JAXP获取SAX解析器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SAXParserFactory factory=SAXParserFactory.newInstance();  </div><div class="line">SAXParser parser=factory.newSAXParser();  </div><div class="line">parser.parse(<span class="string">"F:/Work/Workspace/xiongqi/XmlStudy/test.xml"</span>, handler);</div></pre></td></tr></table></figure></p>
<p>获取DOM解析器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();  </div><div class="line">DocumentBuilder builder= factory.newDocumentBuilder();  </div><div class="line">Document document= builder.parse(<span class="string">"F:/Work/Workspace/xiongqi/XmlStudy/test.xml"</span>);</div></pre></td></tr></table></figure></p>
<p>在 JAXP 的早期版本中，自带解析器的实现为 Apachede 的Crimson，在 JAXP 的新版本中 （包括在 JDK 中） ，Sun 已经重新包装了 Apache Xerces 做为解析器的实现。</p>
<h2 id="JDOM"><a href="#JDOM" class="headerlink" title="JDOM"></a>JDOM</h2><p>由于DOM是为了实现一套跨平台与语言的标准，因此使用它对于JAVA开发人员来说并不是特别的得心应手，这时<code>JDOM</code>就出现了。</p>
<p><code>JDOM</code> 的目的是成为 Java 特定文档模型，它简化与 XML 的交互并且比使用 DOM 实现更快。而且它是第一个 Java 特定模型。与<code>DOM</code>相比较，首先，JDOM 仅使用具体类而不使用接口。这在某些方面简化了API，但是也限制了灵活性。第二，API 大量使用了 Collections 类，相对于dom中的Node，简化了那些已经熟悉这些类的Java 开发者的使用。JDOM 自身不包含解析器，默认使用随jar包一起发行的pache Xerces。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SAXBuilder builder = <span class="keyword">new</span> SAXBuilder(<span class="keyword">false</span>);  </div><div class="line">Document doc = builder.build(in);</div></pre></td></tr></table></figure>
<p>从上面代码中可以看出，JDOM使用SAX2 解析器来解析和验证输入 XML 文档，然后构建Doucment对象。</p>
<h2 id="DOM4J"><a href="#DOM4J" class="headerlink" title="DOM4J"></a>DOM4J</h2><p><code>DOM4J</code>  最初是 JDOM 的一个分支。它合并了许多超出基本 XML 文档表示的功能，包括集成的 XPath 支持、XML Schema 支持以及用于大文档或流化文档的基于事件的处理。它还提供了构建文档表示的选项，它通过 DOM4J API 和标准 DOM 接口具有并行访问功能。</p>
<p>为支持所有这些功能，DOM4J 使用<code>接口</code>和<code>抽象</code>基本类方法。DOM4J 大量使用了 API 中的Collections 类，但是在许多情况下，它还提供一些替代方法以允许更好的性能或更直接的编码方法。直接好处是，虽然 DOM4J 付出了更复杂的 API 的代价，但是它提供了比 JDOM 大得多的灵活性。在添加灵活性、XPath 集成和对大文档处理的目标时，DOM4J 的目标与 JDOM 是一样的：针对 Java开发者的易用性和直观操作。它还致力于成为比 JDOM 更完整的解决方案，实现在本质上处理所有Java/XML 问题的目标。在完成该目标时，它比 JDOM 更少强调防止不正确的应用程序行为。</p>
<p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SAXReader reader = <span class="keyword">new</span> SAXReader(<span class="keyword">false</span>);  </div><div class="line">Document  doc = reader.read(in);</div></pre></td></tr></table></figure></p>
<p>DOM4J 是一个非常非常优秀的Java XML API，具有性能优异、功能强大和极端易用使用的特点，同时它也是一个开放源代码的软件。如今你可以看到越来越多的 Java 软件都在使用 DOM4J 来读写 XML，特别值得一提的是连 Sun 的 JAXM 也在用 DOM4J。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/05/22/octopress-envbuild/" class="prev">上一篇</a><a href="/2014/08/21/stAX-Api-intro/" class="next">下一篇</a></div><div data-thread-key="2014/08/21/javaXml-Api-intro/" data-title="浅析SAX,DOM,JAXP,JDOM与DOM4J之间的关系" data-url="http://www.justin-x.cn/2014/08/21/javaXml-Api-intro/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"Justin-Blog"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260236137'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1260236137%26show%3Dpic' type='text/javascript'%3E%3C/script%3E")); </script>© 2015 - 2016 <a href="http://www.justin-x.cn">Justin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a></p></div><script>(function(){
var bp = document.createElement('script');
var curProtocol = window.location.protocol.split(':')[0];
if (curProtocol === 'https') {
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
}
else {
   bp.src = 'http://push.zhanzhang.baidu.com/push.js';
}
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(bp, s);
})();</script></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>